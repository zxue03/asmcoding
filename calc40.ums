#
#  calc40.ums
#
#  Assignment: asmcoding
#  Authors:    Victoria Chen and Zhicheng Xue
#  Date:       12/11/2020
#  Purpose:    Implemented the RPN calculator, which can execute corresponding
#              .um files. Responsible for reading UM instructions from
#              specified input files. Possible operation include push value on
#              the stack, traditional arithmetic bitwise OR and AND, change
#              sign, bitwise negation, swap two numbers, duplicate, pop,
#              clear the value stack, and print content of the value stack.

#  Calling conventions:
#    Return address in r1
#    Stack pointer in r2
#    r6 and r7 are temp registers
#    Nonvolatiles r0
#    r3 is the value stack pointer
#    r4 holds the new input value - for the most part
#    r0 is zero


.section init
    .temps r6, r7
    .zero r0
    r0 := 0
    r3 := value_stack
    r5 := 0

    # Purpose:   Initialize the jump_table, populate the jump table, and
    #            set each element with appropriate label
    # Arguments: takes no arguments
    # Return:    this is a void procedure
    initialize_jump_table:
      r4 := jump_table
      r4 := r4 + r5
      m[r0][r4] := input_error
      r5 := r5 + 1
      if( r5 <s 256) goto initialize_jump_table using r4
      r5 := 48

    # Purpose:   Set each element in the jump table to point to the digit label.
    # Arguments: takes no arguments
    # Return:    this is a void procedure
    overwrite_digit_entry:
      r4 := jump_table + r5
      m[r0][r4] := digit
      r5 := r5 + 1
      if( r5 <s 58) goto overwrite_digit_entry using r4

    # Purpose:   Initialize the  Takes in the inputs
    #            from the users and execute the operations.
    # Arguments:
    # Return:    this is a void procedure
    command_entry:
      m[r0][jump_table + ' '] := waiting
      m[r0][jump_table + '\n'] := newline
      m[r0][jump_table + '+'] := plus
      m[r0][jump_table + '-'] := sub
      m[r0][jump_table + '*'] := mul
      m[r0][jump_table + '/'] := div
      m[r0][jump_table + '|'] := or
      m[r0][jump_table + '&'] := and
      m[r0][jump_table + 'c'] := change_sign
      m[r0][jump_table + '~'] := not
      m[r0][jump_table + 's'] := swap
      m[r0][jump_table + 'd'] := dup
      m[r0][jump_table + 'p'] := pop_discard
      m[r0][jump_table + 'z'] := zero_stack

.section text
    main:
      push r1 on stack r2
      push r4 on stack r2
      push r3 on stack r2
      goto waiting linking r1
      pop r3 off stack r2
      pop r4 off stack r2
      pop r5 off stack r2
      r1 := 0
      goto r5
    waiting:
      r4 := input()
    waiting_with_character:
      if( r4 == -1) goto r1 using r5
      r5 := jump_table + r4
      r5 := m[r0][r5]
      goto r5
    input_error:
      output "Unknown character '"
      output r4
      output "'\n"
      goto waiting
    digit:
      r4 := r4 - 48
      push r4 on stack r3
    entering:
      r4 := input()
      if( r4 >s 57) goto waiting_with_character using r5
      if( r4 <s 48) goto waiting_with_character using r5
      pop r5 off stack r3
      r5 := 10 * r5
      r4 := r4 - 48
      r4 := r5 + r4
      push r4 on stack r3
      goto entering
    print_stack:
      push r1 on stack r2
      push r4 on stack r2
      push m[r0][r3] on stack r2
      output ">>> "
      goto printd linking r1
      output '\n'
      pop stack r2
      pop r1 off stack r2
      pop r4 off stack r2
      r3 := r3 + 1
      goto print_loop
    newline:
      push r3 on stack r2
      print_loop:
        if(r3 <s value_stack) goto print_stack using r5
        pop r3 off stack r2
        goto waiting
    plus:
      if (r3 >=s value_stack - 1) goto two_elements_error using r5
      push r4 on stack r2
      pop r5 off stack r3
      pop r4 off stack r3
      r5 := r5 + r4
      push r5 on stack r3
      pop r4 off stack r2
      goto waiting
    sub:
      if (r3 >=s value_stack - 1) goto two_elements_error using r5
      push r4 on stack r2
      pop r5 off stack r3
      pop r4 off stack r3
      r5 := r4 - r5
      push r5 on stack r3
      pop r4 off stack r2
      goto waiting
    mul:
      if (r3 >=s value_stack - 1) goto two_elements_error using r5
      push r4 on stack r2
      pop r5 off stack r3
      pop r4 off stack r3
      r5 := r4 * r5 // Tested 6 4 * and print 24H
      push r5 on stack r3
      pop r4 off stack r2
      goto waiting
    div:
      if (r3 >=s value_stack - 1) goto two_elements_error using r5
      push r1 on stack r2
      push r4 on stack r2
      pop r5 off stack r3
      pop r4 off stack r3
      if (r5 == 0) goto div_0_error
      if (r4 <s 0) goto first_negative using r1
      if (r5 <s 0) goto second_negative using r1
      goto pos_pos_result
      first_negative:
        r4 := -r4
        if (r5 >s 0) goto negative_result using r1
        if (r5 <s 0) goto neg_neg_result using r1
      second_negative:
        r5 := -r5
        if (r4 >s 0) goto negative_result using r1
        if (r4 <s 0) goto neg_neg_result using r1
      negative_result:
        r5 := r4 / r5
        r5 := -r5
        goto finish
      neg_neg_result:
        r5 := -r5
        r5 := r4 / r5
        goto finish
      pos_pos_result:
        r5 := r4 / r5
        goto finish
      finish:
        push r5 on stack r3
        pop r4 off stack r2
        pop r1 off stack r2
        goto waiting
      div_0_error:
        output "Division by zero\n"
        push r4 on stack r3
        push r5 on stack r3
        pop r4 off stack r2
        goto waiting
    or:
      if (r3 >=s value_stack - 1) goto two_elements_error using r5
      push r4 on stack r2
      pop r5 off stack r3
      pop r4 off stack r3
      r5 := r4 | r5
      push r5 on stack r3
      pop r4 off stack r2
      goto waiting
    and:
      if (r3 >=s value_stack - 1) goto two_elements_error using r5
      push r4 on stack r2
      pop r5 off stack r3
      pop r4 off stack r3
      r5 := r4 & r5
      push r5 on stack r3
      pop r4 off stack r2
      goto waiting
    change_sign:
      if (r3 == value_stack) goto empty_stack_error using r5
      pop r5 off stack r3
      r5 := -r5
      push r5 on stack r3
      goto waiting
    not:
      if (r3 == value_stack) goto empty_stack_error using r5
      pop r5 off stack r3
      r5 := ~r5
      push r5 on stack r3
      goto waiting
    swap:
      if (r3 >=s value_stack - 1) goto two_elements_error using r5
      push r4 on stack r2
      pop r5 off stack r3
      pop r4 off stack r3
      push r5 on stack r3
      push r4 on stack r3
      pop r4 off stack r2
      goto waiting
    dup:
      if (r3 == value_stack) goto empty_stack_error using r5
      pop r5 off stack r3
      push r5 on stack r3
      push r5 on stack r3
      goto waiting
    pop_discard:
      if (r3 == value_stack) goto empty_stack_error using r5
      pop stack r3
      goto waiting
    zero_stack:
      if( r3 == value_stack) goto waiting using r5
      pop stack r3
      goto zero_stack
    empty_stack_error:
      output "Stack underflow---expected at least 1 element\n"
      goto waiting
    two_elements_error:
      output "Stack underflow---expected at least 2 elements\n"
      goto waiting

# Allocates space for the value_stack
.section data
    .space 1500000
    value_stack:

# Allocates space for the jump table, which directs the process to
# different functions based on inputs
.section rodata
    jump_table:
    .space 256
